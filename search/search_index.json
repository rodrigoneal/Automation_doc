{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Automation Studio Bem vindo ao Prod Studio. Vamos come\u00e7ar com a instala\u00e7\u00e3o e depois vamos cobrir com um Quickstart Demos uma pincelada sobre o Prod Studio . Caracteristicas O Driver faz toda a orquestra\u00e7\u00e3o, n\u00e3o precisando importar fun\u00e7\u00f5es. N\u00e3o precisa ficar chamando o robot toda hora, basta passar o caminho do toml para o Driver. O CLI grava um caminho relativo, facilitando colocar em produ\u00e7\u00e3o em outro ambiente. WaitElement espera o tempo settado. Instala\u00e7\u00e3o pip install git+https://github.com/digital-path/automation_studio#egg=automation_studio","title":"Home"},{"location":"#automation-studio","text":"Bem vindo ao Prod Studio. Vamos come\u00e7ar com a instala\u00e7\u00e3o e depois vamos cobrir com um Quickstart Demos uma pincelada sobre o Prod Studio .","title":"Automation Studio"},{"location":"#caracteristicas","text":"O Driver faz toda a orquestra\u00e7\u00e3o, n\u00e3o precisando importar fun\u00e7\u00f5es. N\u00e3o precisa ficar chamando o robot toda hora, basta passar o caminho do toml para o Driver. O CLI grava um caminho relativo, facilitando colocar em produ\u00e7\u00e3o em outro ambiente. WaitElement espera o tempo settado.","title":"Caracteristicas"},{"location":"#instalacao","text":"pip install git+https://github.com/digital-path/automation_studio#egg=automation_studio","title":"Instala\u00e7\u00e3o"},{"location":"driver/","text":"Usando o Driver O Driver como foi dito \u00e9 o orquestrador do Automation Studio. Ele \u00e9 bem simples basta voc\u00ea passar o caminho do arquivo do .toml. from automation_studio.prod_driver import Driver driver = Driver('arquivo.toml') S\u00f3 isso j\u00e1 \u00e9 necessario para conseguir fazer o driver orquestrar a biblioteca. O Driver retorna um objeto FindElement","title":"Driver"},{"location":"driver/#usando-o-driver","text":"O Driver como foi dito \u00e9 o orquestrador do Automation Studio. Ele \u00e9 bem simples basta voc\u00ea passar o caminho do arquivo do .toml. from automation_studio.prod_driver import Driver driver = Driver('arquivo.toml') S\u00f3 isso j\u00e1 \u00e9 necessario para conseguir fazer o driver orquestrar a biblioteca. O Driver retorna um objeto FindElement","title":"Usando o Driver"},{"location":"execute/","text":"Execute Modulo que re\u00fane algumas fun\u00e7\u00f5es que ajudam no desenvolvimento com o automation studio. importando from automation_studio.action import execute desactive_numlock Gerenciador de contexto que aperta desativa o numlock enquanto executa o comando passado e depois reativa o numlock with desactive_numlock(): pyautogui.hotkey('ctrl','c') Alguns comandos do pyautogui n\u00e3o funciona com o numlock ativo. Return : None submit Aperta o Enter. submit() Return : None copy Copia o elemento com \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_one_click Clica e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_one_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_one_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_double_click Clica duas vezes e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_double_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_double_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_press_home_end Clica no elemento aperta \"Home\" para ir para o come\u00e7o do elemento aperta \"Shift\" + \"End\" para selecionar todo elemento e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_home_end) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_home_end()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_press_space Clica no elemento e aperta \"space\" para selecionar e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_space) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_space()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. hot_key \u00c9 a mistura do puautogui.press e o pyautogui.hotkey. Para n\u00e3o ficar importando a biblioteca pyautogui desnecessariamente. hot_key(args: Union[List, str, Tuple],time_after_press: float = 0, time_before_press: float = 0, **kwargs: Any) args :Union[List, str, Tuple]: Se for passado um str vai chamada o press do pyautogui, se passar uma lista ou tupla ele vai chamar o hotkey Exemplo: execute.hot_key('space') Ele s\u00f3 vai aperta o \"Space\" execute.hot_key(['ctrl', 'c']) Ele vai segura o \"CTRL\" e apertar \"C\" time/ after/_press _: float: Tempo que vai parar depois de apertar os bot\u00f5es. time/ before/_press _: float: Tempo que vai parar antes de apertar os bot\u00f5es. Exemplo: execute.hot_key('space', time_before_press=1, time_after_press=1) Nesse exemplo ele vai travar a execu\u00e7\u00e3o por 1 segundo, apertar \"Space\" e travar a execu\u00e7\u00e3o por 1 segundo.","title":"Execute"},{"location":"execute/#execute","text":"Modulo que re\u00fane algumas fun\u00e7\u00f5es que ajudam no desenvolvimento com o automation studio.","title":"Execute"},{"location":"execute/#importando","text":"from automation_studio.action import execute","title":"importando"},{"location":"execute/#desactive_numlock","text":"Gerenciador de contexto que aperta desativa o numlock enquanto executa o comando passado e depois reativa o numlock with desactive_numlock(): pyautogui.hotkey('ctrl','c') Alguns comandos do pyautogui n\u00e3o funciona com o numlock ativo. Return : None","title":"desactive_numlock"},{"location":"execute/#submit","text":"Aperta o Enter. submit() Return : None","title":"submit"},{"location":"execute/#copy","text":"Copia o elemento com \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy"},{"location":"execute/#copy_one_click","text":"Clica e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_one_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_one_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_one_click"},{"location":"execute/#copy_double_click","text":"Clica duas vezes e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_double_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_double_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_double_click"},{"location":"execute/#copy_press_home_end","text":"Clica no elemento aperta \"Home\" para ir para o come\u00e7o do elemento aperta \"Shift\" + \"End\" para selecionar todo elemento e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_home_end) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_home_end()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_press_home_end"},{"location":"execute/#copy_press_space","text":"Clica no elemento e aperta \"space\" para selecionar e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_space) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_space()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_press_space"},{"location":"execute/#hot_key","text":"\u00c9 a mistura do puautogui.press e o pyautogui.hotkey. Para n\u00e3o ficar importando a biblioteca pyautogui desnecessariamente. hot_key(args: Union[List, str, Tuple],time_after_press: float = 0, time_before_press: float = 0, **kwargs: Any) args :Union[List, str, Tuple]: Se for passado um str vai chamada o press do pyautogui, se passar uma lista ou tupla ele vai chamar o hotkey Exemplo: execute.hot_key('space') Ele s\u00f3 vai aperta o \"Space\" execute.hot_key(['ctrl', 'c']) Ele vai segura o \"CTRL\" e apertar \"C\" time/ after/_press _: float: Tempo que vai parar depois de apertar os bot\u00f5es. time/ before/_press _: float: Tempo que vai parar antes de apertar os bot\u00f5es. Exemplo: execute.hot_key('space', time_before_press=1, time_after_press=1) Nesse exemplo ele vai travar a execu\u00e7\u00e3o por 1 segundo, apertar \"Space\" e travar a execu\u00e7\u00e3o por 1 segundo.","title":"hot_key"},{"location":"find/","text":"Encontrando Elemento Classe FindElement A classe FindElement tem as fun\u00e7\u00f5es para localizar o elemento na tela. find_element driver.find_element(\"elemento\") Procura o elemento na tela. find_element(*paths: str) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. Return : FireHiving: Objeto d\u00e1 interatividade ao elemento. first_to_find Procura o elemento na tela e retorna o primeiro elemento que encontrar. first_to_find(*paths: str, tip: List[int] = None) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. tip : int: Dica na tela de onde fica a imagem/video procurado Return : FireHiving: Objeto d\u00e1 interatividade ao elemento. implicitly_wait Vai travar a execu\u00e7\u00e3o do programa pelo tempo passado. \u00c9 bem parecido com o sleep. implicitly_wait(time: float) time :float: tempo que vai travar a execu\u00e7\u00e3o do programa.","title":"FindElement"},{"location":"find/#encontrando-elemento","text":"","title":"Encontrando Elemento"},{"location":"find/#classe-findelement","text":"A classe FindElement tem as fun\u00e7\u00f5es para localizar o elemento na tela.","title":"Classe FindElement"},{"location":"find/#find_element","text":"driver.find_element(\"elemento\") Procura o elemento na tela. find_element(*paths: str) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. Return : FireHiving: Objeto d\u00e1 interatividade ao elemento.","title":"find_element"},{"location":"find/#first_to_find","text":"Procura o elemento na tela e retorna o primeiro elemento que encontrar. first_to_find(*paths: str, tip: List[int] = None) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. tip : int: Dica na tela de onde fica a imagem/video procurado Return : FireHiving: Objeto d\u00e1 interatividade ao elemento.","title":"first_to_find"},{"location":"find/#implicitly_wait","text":"Vai travar a execu\u00e7\u00e3o do programa pelo tempo passado. \u00c9 bem parecido com o sleep. implicitly_wait(time: float) time :float: tempo que vai travar a execu\u00e7\u00e3o do programa.","title":"implicitly_wait"},{"location":"fire/","text":"Interagindo com Elemento Depois de encontrar o elemento voc\u00ea normalmente vai querer interagir com ele. E \u00e9 nessa se\u00e7\u00e3o que voc\u00ea vai aprender as principais fun\u00e7\u00f5es. Click Clica no elemento. driver.find_element(\"elemento\").click() click(button: str = \"left\", clicks: int = 1, time_until_click: float = 0) button : str: Qual lado do mouse vai ser clicado. clicks : int: Quantas vezes o mouse vai clicar. time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None Hover Move o mouse para cima do elemento. driver.find_element(\"elemento\").hover() hover(time_until_hover: float = 0) time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None Writter Escreve o texto no elemento. driver.find_element(\"elemento\").writter() writter(text: str, clear: bool = False, time_until_writter: float = 0) text : str: Texto que ser\u00e1 escrito no elemento. clear : bool: Apaga o texto que j\u00e1 est\u00e1 no elemento antes de escrever. time until_writter _: float: Clica no elemento e aguarda o tempo passado antes de escrever. Return : None Copy Copia o elemento. driver.find_element(\"elemento\").copy() copy(func_copy: Any, safe_copy: bool = False, time_until_copy: float = 0) func_copy : Any: Fun\u00e7\u00e3o que ser\u00e1 chamada para fazer a copia. \"Detalhes abaixo\" safe_copy : bool: Certifica que a copia n\u00e3o est\u00e1 vazia. time_until_copy : float: Clica no elemento e aguarda o tempo passado antes de copiar. Return : None Algumas fun\u00e7\u00f5es para usar com o func copy _ est\u00e3o no modulo Execute , mas voc\u00ea tamb\u00e9m pode fazer a sua propria fun\u00e7\u00e3o. Drag_and_drop Clica e arrasta um elemento para cima do outro. driver.find_element(\"elemento_drag\", \"elemento_drop\").drag_and_drop() drag_and_drop(duration: float = 0.5) duration :float: Tempo que arrasta um elemento no outro Return : None Is_displayed driver.find_element(\"elemento\").is_displayed() Mostra se o elemento est\u00e1 na tela is_displayed() Return : bool x","title":"FireHiving"},{"location":"fire/#interagindo-com-elemento","text":"Depois de encontrar o elemento voc\u00ea normalmente vai querer interagir com ele. E \u00e9 nessa se\u00e7\u00e3o que voc\u00ea vai aprender as principais fun\u00e7\u00f5es.","title":"Interagindo com Elemento"},{"location":"fire/#click","text":"Clica no elemento. driver.find_element(\"elemento\").click() click(button: str = \"left\", clicks: int = 1, time_until_click: float = 0) button : str: Qual lado do mouse vai ser clicado. clicks : int: Quantas vezes o mouse vai clicar. time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None","title":"Click"},{"location":"fire/#hover","text":"Move o mouse para cima do elemento. driver.find_element(\"elemento\").hover() hover(time_until_hover: float = 0) time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None","title":"Hover"},{"location":"fire/#writter","text":"Escreve o texto no elemento. driver.find_element(\"elemento\").writter() writter(text: str, clear: bool = False, time_until_writter: float = 0) text : str: Texto que ser\u00e1 escrito no elemento. clear : bool: Apaga o texto que j\u00e1 est\u00e1 no elemento antes de escrever. time until_writter _: float: Clica no elemento e aguarda o tempo passado antes de escrever. Return : None","title":"Writter"},{"location":"fire/#copy","text":"Copia o elemento. driver.find_element(\"elemento\").copy() copy(func_copy: Any, safe_copy: bool = False, time_until_copy: float = 0) func_copy : Any: Fun\u00e7\u00e3o que ser\u00e1 chamada para fazer a copia. \"Detalhes abaixo\" safe_copy : bool: Certifica que a copia n\u00e3o est\u00e1 vazia. time_until_copy : float: Clica no elemento e aguarda o tempo passado antes de copiar. Return : None Algumas fun\u00e7\u00f5es para usar com o func copy _ est\u00e3o no modulo Execute , mas voc\u00ea tamb\u00e9m pode fazer a sua propria fun\u00e7\u00e3o.","title":"Copy"},{"location":"fire/#drag_and_drop","text":"Clica e arrasta um elemento para cima do outro. driver.find_element(\"elemento_drag\", \"elemento_drop\").drag_and_drop() drag_and_drop(duration: float = 0.5) duration :float: Tempo que arrasta um elemento no outro Return : None","title":"Drag_and_drop"},{"location":"fire/#is_displayed","text":"driver.find_element(\"elemento\").is_displayed() Mostra se o elemento est\u00e1 na tela is_displayed() Return : bool x","title":"Is_displayed"},{"location":"prodstudio/","text":"Prod Studio N\u00e3o tem como usar o Automation Studio sem aprender o basico do Prod Studio . Com a nova vers\u00e3o do Prod Studio voc\u00ea n\u00e3o precisa mais criar a pasta e o arquivo .toml. na chamada do Prod Studio voc\u00ea passa o nome dos arquivos. Exemplo: python -m prod_studio config.toml img Se n\u00e3o arquivos n\u00e3o existirem, o prod_studio vai criar automaticamente. Como Usar Crie uma pasta onde ficar\u00e1 as imagens e videos (Por padr\u00e3o usamos \"img\"). Crie um arquivo .toml (Por padr\u00e3o usamos \"config.toml\"). config.toml # Arquivo toml com os caminhos das imagens. img/ # Pasta com as imagens. logo.img # Imagem usada pelo robo. ... # images and outros arquivos. O Automation Studio faz a instala\u00e7\u00e3o do prod studio por dependencia, mas caso deseja pode fazer a instala\u00e7\u00e3o pelo pip. pip install git+https://github.com/digital-path/prod_studio@default#egg=prod_studio Mapeando o elemento python -m prod_studio config.toml img Mapeamento Simples. Exemplo: Mapear o logo da Google. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F1 e levemente arraste para a parte inferior direita e aperte F1 novamente para finalizar o mapeamento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. O terminal vai mostrar as chances do rob\u00f4 encontrar aquele elemento na tela. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Mapeamento Multipla Exemplo: Mapear s\u00f3 um \"O\" do logo da Google. A sele\u00e7\u00e3o multipla \u00e9 bem parecida com a sele\u00e7\u00e3o simples. Coloque o mouse na parte superior esquerda do elemento pai aperte F2 e levemente arraste o mouse para a parte inferior direita e aperte F2 . Agora vai ao elemento filho que deseja mapear e fa\u00e7a o mesmo procedimento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. Dentro do .toml ser\u00e1 salvo um tip, esse tip \u00e9 a dica de onde o bot vai procurar o elemento. Primeiro faz o mapeamento do elemento pai. Depois faz o mapeamento do elemento filho dentro do pai. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Mapeamento OCR A sele\u00e7\u00e3o OCR encontra um texto na tela. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F3 e levemente arraste para a parte inferior direita e aperte F3 novamente para finalizar o mapeamento. O modo de sele\u00e7\u00e3o \u00e9 muito parecido com a sele\u00e7\u00e3o simples, mas n\u00e3o mostrar\u00e1 a precis\u00e3o do bot achar o elemento e sim o texto na tela encontrando. O texto ser\u00e1 salvo dentro do .toml com o tip. Voc\u00ea pode apagar o expected_text para encontrar qualquer texto dentro daquele tip. Mapeamento por video Bem parecido com a sele\u00e7\u00e3o simples. Ele grava a tela e salva como video. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F4 e levemente arraste para a parte inferior direita e aperte F4 novamente come\u00e7ar a gravar. Um contador vai mostrar o tempo de grava\u00e7\u00e3o. Aperte F4 para finalizar a grava\u00e7\u00e3o. O Video ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo do video ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio.","title":"Quickstart"},{"location":"prodstudio/#prod-studio","text":"N\u00e3o tem como usar o Automation Studio sem aprender o basico do Prod Studio . Com a nova vers\u00e3o do Prod Studio voc\u00ea n\u00e3o precisa mais criar a pasta e o arquivo .toml. na chamada do Prod Studio voc\u00ea passa o nome dos arquivos. Exemplo: python -m prod_studio config.toml img Se n\u00e3o arquivos n\u00e3o existirem, o prod_studio vai criar automaticamente.","title":"Prod Studio"},{"location":"prodstudio/#como-usar","text":"Crie uma pasta onde ficar\u00e1 as imagens e videos (Por padr\u00e3o usamos \"img\"). Crie um arquivo .toml (Por padr\u00e3o usamos \"config.toml\"). config.toml # Arquivo toml com os caminhos das imagens. img/ # Pasta com as imagens. logo.img # Imagem usada pelo robo. ... # images and outros arquivos. O Automation Studio faz a instala\u00e7\u00e3o do prod studio por dependencia, mas caso deseja pode fazer a instala\u00e7\u00e3o pelo pip. pip install git+https://github.com/digital-path/prod_studio@default#egg=prod_studio","title":"Como Usar"},{"location":"prodstudio/#mapeando-o-elemento","text":"python -m prod_studio config.toml img","title":"Mapeando o elemento"},{"location":"prodstudio/#mapeamento-simples","text":"Exemplo: Mapear o logo da Google. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F1 e levemente arraste para a parte inferior direita e aperte F1 novamente para finalizar o mapeamento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. O terminal vai mostrar as chances do rob\u00f4 encontrar aquele elemento na tela. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9","title":"Mapeamento Simples."},{"location":"prodstudio/#mapeamento-multipla","text":"Exemplo: Mapear s\u00f3 um \"O\" do logo da Google. A sele\u00e7\u00e3o multipla \u00e9 bem parecida com a sele\u00e7\u00e3o simples. Coloque o mouse na parte superior esquerda do elemento pai aperte F2 e levemente arraste o mouse para a parte inferior direita e aperte F2 . Agora vai ao elemento filho que deseja mapear e fa\u00e7a o mesmo procedimento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. Dentro do .toml ser\u00e1 salvo um tip, esse tip \u00e9 a dica de onde o bot vai procurar o elemento. Primeiro faz o mapeamento do elemento pai. Depois faz o mapeamento do elemento filho dentro do pai. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9","title":"Mapeamento Multipla"},{"location":"prodstudio/#mapeamento-ocr","text":"A sele\u00e7\u00e3o OCR encontra um texto na tela. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F3 e levemente arraste para a parte inferior direita e aperte F3 novamente para finalizar o mapeamento. O modo de sele\u00e7\u00e3o \u00e9 muito parecido com a sele\u00e7\u00e3o simples, mas n\u00e3o mostrar\u00e1 a precis\u00e3o do bot achar o elemento e sim o texto na tela encontrando. O texto ser\u00e1 salvo dentro do .toml com o tip. Voc\u00ea pode apagar o expected_text para encontrar qualquer texto dentro daquele tip.","title":"Mapeamento OCR"},{"location":"prodstudio/#mapeamento-por-video","text":"Bem parecido com a sele\u00e7\u00e3o simples. Ele grava a tela e salva como video. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F4 e levemente arraste para a parte inferior direita e aperte F4 novamente come\u00e7ar a gravar. Um contador vai mostrar o tempo de grava\u00e7\u00e3o. Aperte F4 para finalizar a grava\u00e7\u00e3o. O Video ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo do video ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio.","title":"Mapeamento por video"},{"location":"wait/","text":"WaitElement Alguns elementos podem demorar aparecer na tela. A classe WaitElement aguarda at\u00e9 que o elemento esteja vis\u00edvel na tela para intera\u00e7\u00e3o. Fa\u00e7a a importa\u00e7\u00e3o da classe: from automation_studio.prod_driver.wait import WaitElement Como Usar WaitElement(driver: FindElement = None, time_wait=0) driver : type FindElement: Obejeto driver com o arquivo .toml. time_wait : type float: Tempo em segundos que vai aguardar at\u00e9 encontrar o elemento. Return : FireHivingElement Se passar o tempo passado a classe vai retornar uma exce\u00e7\u00e3o ElementNotFoundException. Aguardando Elemento Agora \u00e9 encontrar o elemento que vamos aguardar. A classe WaitElement possui os metodos find , scroll_page e while_present find O find vai tentar encontrar o elemento passado pelo tempo passado. Voc\u00ea pode passar um str . Exemplo: WaitElement(driver, 10).find('elemento') Voc\u00ea tamb\u00e9m pode passar uma list . Exemplo: WaitElement(driver, 10).find(['elemento1','elemento2']) Se passar um str ele vai procurar somente esse elemento, mas se passar uma lista de elementos ele vai retornar o primeiro elemento que encontrar igual ao metodo first_to_find aqui . find(element: Union[List, str]) element : [List, str]: Elemento que deseja encontrar na tela. Return : FireHivingElement scroll_page WaitElement(driver, 10).scroll_page() O metodo scroll_page vai rolar a tela at\u00e9 encontrar o elemento. scroll_page(element: Union[List, str], direction: str = \"down\", scroll_speed: int = 100, time_between_scrolling: float = 0.5) element : [List, str]: Elemento que deseja encontrar na tela. direction : str: Dire\u00e7\u00e3o que deseja que a tela vai rolar pode ser \"up\" ou \"down\". scroll speed _: int: Velocidade em cliques que a tela vai rolar. time between_scrolling _: float: Tempo que o metodo vai aguardar entre uma rolagem e outra. Return : FireHivingElement while_present WaitElement(driver, 10).while_present() O metodo vai parar a execu\u00e7\u00e3o at\u00e9 que o elemento passado n\u00e3o esteja mais presente na tela. Exemplo: H\u00e1 uma tela de loading e voc\u00ea quer que a execu\u00e7\u00e3o retorne quando esse loading sair, ent\u00e3o use esse metodo e passe o tempo que deseja na chamada da classe. Preste bastante aten\u00e7\u00e3o a isso. Pois ele s\u00f3 vai aguardar pelo tempo passado na chamada da classe no time_wait . element : [List, str]: Elemento que deseja encontrar na tela. O elemento se comporta do mesmo jeito que o find. Se passar um str vai pegar o elemento, se passar list ele vai retornar o primeiro elemento que encontrar. Como esse metodo \u00e9 s\u00f3 um bloqueante ele n\u00e3o tem retorno. Return : None","title":"WaitElement"},{"location":"wait/#waitelement","text":"Alguns elementos podem demorar aparecer na tela. A classe WaitElement aguarda at\u00e9 que o elemento esteja vis\u00edvel na tela para intera\u00e7\u00e3o. Fa\u00e7a a importa\u00e7\u00e3o da classe: from automation_studio.prod_driver.wait import WaitElement","title":"WaitElement"},{"location":"wait/#como-usar","text":"WaitElement(driver: FindElement = None, time_wait=0) driver : type FindElement: Obejeto driver com o arquivo .toml. time_wait : type float: Tempo em segundos que vai aguardar at\u00e9 encontrar o elemento. Return : FireHivingElement Se passar o tempo passado a classe vai retornar uma exce\u00e7\u00e3o ElementNotFoundException.","title":"Como Usar"},{"location":"wait/#aguardando-elemento","text":"Agora \u00e9 encontrar o elemento que vamos aguardar. A classe WaitElement possui os metodos find , scroll_page e while_present","title":"Aguardando Elemento"},{"location":"wait/#find","text":"O find vai tentar encontrar o elemento passado pelo tempo passado. Voc\u00ea pode passar um str . Exemplo: WaitElement(driver, 10).find('elemento') Voc\u00ea tamb\u00e9m pode passar uma list . Exemplo: WaitElement(driver, 10).find(['elemento1','elemento2']) Se passar um str ele vai procurar somente esse elemento, mas se passar uma lista de elementos ele vai retornar o primeiro elemento que encontrar igual ao metodo first_to_find aqui . find(element: Union[List, str]) element : [List, str]: Elemento que deseja encontrar na tela. Return : FireHivingElement","title":"find"},{"location":"wait/#scroll_page","text":"WaitElement(driver, 10).scroll_page() O metodo scroll_page vai rolar a tela at\u00e9 encontrar o elemento. scroll_page(element: Union[List, str], direction: str = \"down\", scroll_speed: int = 100, time_between_scrolling: float = 0.5) element : [List, str]: Elemento que deseja encontrar na tela. direction : str: Dire\u00e7\u00e3o que deseja que a tela vai rolar pode ser \"up\" ou \"down\". scroll speed _: int: Velocidade em cliques que a tela vai rolar. time between_scrolling _: float: Tempo que o metodo vai aguardar entre uma rolagem e outra. Return : FireHivingElement","title":"scroll_page"},{"location":"wait/#while_present","text":"WaitElement(driver, 10).while_present() O metodo vai parar a execu\u00e7\u00e3o at\u00e9 que o elemento passado n\u00e3o esteja mais presente na tela. Exemplo: H\u00e1 uma tela de loading e voc\u00ea quer que a execu\u00e7\u00e3o retorne quando esse loading sair, ent\u00e3o use esse metodo e passe o tempo que deseja na chamada da classe. Preste bastante aten\u00e7\u00e3o a isso. Pois ele s\u00f3 vai aguardar pelo tempo passado na chamada da classe no time_wait . element : [List, str]: Elemento que deseja encontrar na tela. O elemento se comporta do mesmo jeito que o find. Se passar um str vai pegar o elemento, se passar list ele vai retornar o primeiro elemento que encontrar. Como esse metodo \u00e9 s\u00f3 um bloqueante ele n\u00e3o tem retorno. Return : None","title":"while_present"}]}