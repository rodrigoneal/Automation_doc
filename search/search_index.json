{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Automation Studio Bem vindo ao Prod Studio. Vamos come\u00e7ar com a instala\u00e7\u00e3o e depois vamos cobrir com um Quickstart Demos uma pincelada sobre o Prod Studio . Caracteristicas O Driver faz toda a orquestra\u00e7\u00e3o, n\u00e3o precisando importar fun\u00e7\u00f5es. N\u00e3o precisa ficar chamando o robot toda hora, basta passar o caminho do toml para o Driver. O CLI grava um caminho relativo, facilitando colocar em produ\u00e7\u00e3o em outro ambiente. WaitElement espera o tempo settado. Instala\u00e7\u00e3o pip install git+https://github.com/digital-path/automation_studio#egg=automation_studio","title":"Automation Studio"},{"location":"#automation-studio","text":"Bem vindo ao Prod Studio. Vamos come\u00e7ar com a instala\u00e7\u00e3o e depois vamos cobrir com um Quickstart Demos uma pincelada sobre o Prod Studio .","title":"Automation Studio"},{"location":"#caracteristicas","text":"O Driver faz toda a orquestra\u00e7\u00e3o, n\u00e3o precisando importar fun\u00e7\u00f5es. N\u00e3o precisa ficar chamando o robot toda hora, basta passar o caminho do toml para o Driver. O CLI grava um caminho relativo, facilitando colocar em produ\u00e7\u00e3o em outro ambiente. WaitElement espera o tempo settado.","title":"Caracteristicas"},{"location":"#instalacao","text":"pip install git+https://github.com/digital-path/automation_studio#egg=automation_studio","title":"Instala\u00e7\u00e3o"},{"location":"quick/","text":"Quickstart Vamos fazer o Automation Studio encontrar e clicar no logo do pycharm. Mapear o elemento com o prod studio . python -m prod_studio config.toml img O prod studio vai criar o arquivo \"config.toml\" para escrever o caminho das imagens e a pasta \"img\" onde v\u00e3o ficar as imagens. Essa \u00e9 a tela que vamos mapear. Vamos pegar s\u00f3 o logo do pycharm que fica na parte superior esquerda. Vamos fazer um mapeamento simples. Apertando F1 . Coloque o mouse na parte superior do elemento que deseja mapear e preste aten\u00e7\u00e3o na precis\u00e3o de encontrar o elemento mostrado no terminal. Quando atingir uma boa precis\u00e3o basta apertar F1 para finalizar o mapeamento. D\u00ea nome ao elemento. N\u00e3o precisa colocar a extens\u00e3o da imagem, s\u00f3 o nome que ser\u00e1 a chave dentro do toml. Usando o Driver do Automation Studio. Importe o Driver do automation studio. from automation_studio.prod_driver import Driver Passe o caminho do toml para dentro do Driver. driver = Driver('config.toml') Localizando o elemento. driver.find_element('logo') O find_element vai procurar o elemento \"logo\" que demos o nome quando mapeamos. Voc\u00ea pode salvar em uma varialvel ou pode interagir com elemento. Interagindo com o elemento. Vamos clicar no elemento. driver.find_element('logo').click() A magia acontece","title":"Quick start"},{"location":"quick/#quickstart","text":"Vamos fazer o Automation Studio encontrar e clicar no logo do pycharm.","title":"Quickstart"},{"location":"quick/#mapear-o-elemento-com-o-prod-studio","text":"python -m prod_studio config.toml img O prod studio vai criar o arquivo \"config.toml\" para escrever o caminho das imagens e a pasta \"img\" onde v\u00e3o ficar as imagens. Essa \u00e9 a tela que vamos mapear. Vamos pegar s\u00f3 o logo do pycharm que fica na parte superior esquerda. Vamos fazer um mapeamento simples. Apertando F1 . Coloque o mouse na parte superior do elemento que deseja mapear e preste aten\u00e7\u00e3o na precis\u00e3o de encontrar o elemento mostrado no terminal. Quando atingir uma boa precis\u00e3o basta apertar F1 para finalizar o mapeamento. D\u00ea nome ao elemento. N\u00e3o precisa colocar a extens\u00e3o da imagem, s\u00f3 o nome que ser\u00e1 a chave dentro do toml.","title":"Mapear o elemento com o prod studio."},{"location":"quick/#usando-o-driver-do-automation-studio","text":"Importe o Driver do automation studio. from automation_studio.prod_driver import Driver Passe o caminho do toml para dentro do Driver. driver = Driver('config.toml')","title":"Usando o Driver do Automation Studio."},{"location":"quick/#localizando-o-elemento","text":"driver.find_element('logo') O find_element vai procurar o elemento \"logo\" que demos o nome quando mapeamos. Voc\u00ea pode salvar em uma varialvel ou pode interagir com elemento.","title":"Localizando o elemento."},{"location":"quick/#interagindo-com-o-elemento","text":"Vamos clicar no elemento. driver.find_element('logo').click()","title":"Interagindo com o elemento."},{"location":"quick/#a-magia-acontece","text":"","title":"A magia acontece"},{"location":"wait/","text":"WaitElement Alguns elementos podem demorar aparecer na tela. A classe WaitElement aguarda at\u00e9 que o elemento esteja vis\u00edvel na tela para intera\u00e7\u00e3o. Fa\u00e7a a importa\u00e7\u00e3o da classe: from automation_studio.prod_driver.wait import WaitElement Como Usar WaitElement(driver: FindElement = None, time_wait=0) driver : type FindElement: Obejeto driver com o arquivo .toml. time_wait : type float: Tempo em segundos que vai aguardar at\u00e9 encontrar o elemento. Return : FireHivingElement Se passar o tempo passado a classe vai retornar uma exce\u00e7\u00e3o ElementNotFoundException. Aguardando Elemento Agora \u00e9 encontrar o elemento que vamos aguardar. A classe WaitElement possui os metodos find , scroll_page e while_present find O find vai tentar encontrar o elemento passado pelo tempo passado. Voc\u00ea pode passar um str . Exemplo: WaitElement(driver, 10).find('elemento') Voc\u00ea tamb\u00e9m pode passar uma list . Exemplo: WaitElement(driver, 10).find(['elemento1','elemento2']) Se passar um str ele vai procurar somente esse elemento, mas se passar uma lista de elementos ele vai retornar o primeiro elemento que encontrar igual ao metodo first_to_find aqui . find(element: Union[List, str]) element : [List, str]: Elemento que deseja encontrar na tela. Return : FireHivingElement scroll_page WaitElement(driver, 10).scroll_page() O metodo scroll_page vai rolar a tela at\u00e9 encontrar o elemento. scroll_page(element: Union[List, str], direction: str = \"down\", scroll_speed: int = 100, time_between_scrolling: float = 0.5) element : [List, str]: Elemento que deseja encontrar na tela. direction : str: Dire\u00e7\u00e3o que deseja que a tela vai rolar pode ser \"up\" ou \"down\". scroll speed _: int: Velocidade em cliques que a tela vai rolar. time between_scrolling _: float: Tempo que o metodo vai aguardar entre uma rolagem e outra. Return : FireHivingElement while_present WaitElement(driver, 10).while_present() O metodo vai parar a execu\u00e7\u00e3o at\u00e9 que o elemento passado n\u00e3o esteja mais presente na tela. Exemplo: H\u00e1 uma tela de loading e voc\u00ea quer que a execu\u00e7\u00e3o retorne quando esse loading sair, ent\u00e3o use esse metodo e passe o tempo que deseja na chamada da classe. Preste bastante aten\u00e7\u00e3o a isso. Pois ele s\u00f3 vai aguardar pelo tempo passado na chamada da classe no time_wait . element : [List, str]: Elemento que deseja encontrar na tela. O elemento se comporta do mesmo jeito que o find. Se passar um str vai pegar o elemento, se passar list ele vai retornar o primeiro elemento que encontrar. Como esse metodo \u00e9 s\u00f3 um bloqueante ele n\u00e3o tem retorno. Return : None","title":"WaitElement"},{"location":"wait/#waitelement","text":"Alguns elementos podem demorar aparecer na tela. A classe WaitElement aguarda at\u00e9 que o elemento esteja vis\u00edvel na tela para intera\u00e7\u00e3o. Fa\u00e7a a importa\u00e7\u00e3o da classe: from automation_studio.prod_driver.wait import WaitElement","title":"WaitElement"},{"location":"wait/#como-usar","text":"WaitElement(driver: FindElement = None, time_wait=0) driver : type FindElement: Obejeto driver com o arquivo .toml. time_wait : type float: Tempo em segundos que vai aguardar at\u00e9 encontrar o elemento. Return : FireHivingElement Se passar o tempo passado a classe vai retornar uma exce\u00e7\u00e3o ElementNotFoundException.","title":"Como Usar"},{"location":"wait/#aguardando-elemento","text":"Agora \u00e9 encontrar o elemento que vamos aguardar. A classe WaitElement possui os metodos find , scroll_page e while_present","title":"Aguardando Elemento"},{"location":"wait/#find","text":"O find vai tentar encontrar o elemento passado pelo tempo passado. Voc\u00ea pode passar um str . Exemplo: WaitElement(driver, 10).find('elemento') Voc\u00ea tamb\u00e9m pode passar uma list . Exemplo: WaitElement(driver, 10).find(['elemento1','elemento2']) Se passar um str ele vai procurar somente esse elemento, mas se passar uma lista de elementos ele vai retornar o primeiro elemento que encontrar igual ao metodo first_to_find aqui . find(element: Union[List, str]) element : [List, str]: Elemento que deseja encontrar na tela. Return : FireHivingElement","title":"find"},{"location":"wait/#scroll_page","text":"WaitElement(driver, 10).scroll_page() O metodo scroll_page vai rolar a tela at\u00e9 encontrar o elemento. scroll_page(element: Union[List, str], direction: str = \"down\", scroll_speed: int = 100, time_between_scrolling: float = 0.5) element : [List, str]: Elemento que deseja encontrar na tela. direction : str: Dire\u00e7\u00e3o que deseja que a tela vai rolar pode ser \"up\" ou \"down\". scroll speed _: int: Velocidade em cliques que a tela vai rolar. time between_scrolling _: float: Tempo que o metodo vai aguardar entre uma rolagem e outra. Return : FireHivingElement","title":"scroll_page"},{"location":"wait/#while_present","text":"WaitElement(driver, 10).while_present() O metodo vai parar a execu\u00e7\u00e3o at\u00e9 que o elemento passado n\u00e3o esteja mais presente na tela. Exemplo: H\u00e1 uma tela de loading e voc\u00ea quer que a execu\u00e7\u00e3o retorne quando esse loading sair, ent\u00e3o use esse metodo e passe o tempo que deseja na chamada da classe. Preste bastante aten\u00e7\u00e3o a isso. Pois ele s\u00f3 vai aguardar pelo tempo passado na chamada da classe no time_wait . element : [List, str]: Elemento que deseja encontrar na tela. O elemento se comporta do mesmo jeito que o find. Se passar um str vai pegar o elemento, se passar list ele vai retornar o primeiro elemento que encontrar. Como esse metodo \u00e9 s\u00f3 um bloqueante ele n\u00e3o tem retorno. Return : None","title":"while_present"},{"location":"action/execute/","text":"Execute Modulo que re\u00fane algumas fun\u00e7\u00f5es que ajudam no desenvolvimento com o automation studio. Importando from automation_studio.action import execute desactive_numlock Gerenciador de contexto que desativa o numlock enquanto executa o comando passado e reativa o numlock with desactive_numlock(): pyautogui.hotkey('ctrl','c') Alguns comandos do pyautogui n\u00e3o funciona com o numlock ativo. Return : None submit Aperta o Enter. submit() Return : None copy Copia o elemento com \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_one_click Clica e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_one_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_one_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_double_click Clica duas vezes e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_double_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_double_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_press_home_end Clica no elemento aperta \"Home\" para ir para o come\u00e7o do elemento aperta \"Shift\" + \"End\" para selecionar todo elemento e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_home_end) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_home_end()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. copy_press_space Clica no elemento e aperta \"space\" para selecionar e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_space) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_space()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado. hot_key Executa comandos de teclado. \u00c9 a mistura do puautogui.press e o pyautogui.hotkey. Para n\u00e3o ficar importando a biblioteca pyautogui desnecessariamente. hot_key(args: Union[List, str, Tuple],time_after_press: float = 0, time_before_press: float = 0, **kwargs: Any) args :Union[List, str, Tuple]: Se for passado um str vai chamada o press do pyautogui, se passar uma lista ou tupla ele vai chamar o hotkey Exemplo: execute.hot_key('space') Ele s\u00f3 vai aperta o \"Space\" execute.hot_key(['ctrl', 'c']) Ele vai segura o \"CTRL\" e apertar \"C\" time/ after/_press _: float: Tempo que vai parar depois de apertar os bot\u00f5es. time/ before/_press _: float: Tempo que vai parar antes de apertar os bot\u00f5es. Exemplo: execute.hot_key('space', time_before_press=1, time_after_press=1) Nesse exemplo ele vai travar a execu\u00e7\u00e3o por 1 segundo, apertar \"Space\" e travar a execu\u00e7\u00e3o por 1 segundo. Return : None maximize_screen Maximiza a tela. time/ before/_press _: float: Tempo que vai parar antes de maximiza a tela. Return : None center_mouse Coloca o mouse no centro da tela. Return : None run_on_subprocess Executa comandos no prompt. driver : Driver: Driver com o arquivo toml. command : str: Comando dentro do toml que deseja executar. Exemplo: Vamos abrir o SAP. driver = Drive('config.toml') run_on_subprocess(driver, 'sap') Dentro do toml voc\u00ea precisa passar a do sap com o caminho do executavel. [command] sap = \"C:/Program Files (x86)/SAP/FrontEnd/SAPgui/saplogon.exe\" O run_on_subprocess vai dentro do toml buscar a chave command pegando o caminho do executavel do SAP. Return : None window_close Fecha o programa. Vai fazer o \"ALT\" + \"F4\" simples. Return : None kill_process Mata o processo. Pode passar o nome do processo ou o PID. process : Union[str, int]: Nome ou PID do processo que deseja encerrar. Se passar o nome do processo n\u00e3o precisa passar a extens\u00e3o dele. Exemplo: Vamos fechar o chrome. kill_process('chrome') N\u00e3o precisa passar kill_process('chrome.exe') . Return : None pid_process retorna o PID do processo. process :str: Nome do processo que deseja o PID. Return : int: O PID. list_all_process Lista todos os processos no sistema. Return : List[dict[str, int]]: todos os processos do sistema.","title":"Execute"},{"location":"action/execute/#execute","text":"Modulo que re\u00fane algumas fun\u00e7\u00f5es que ajudam no desenvolvimento com o automation studio.","title":"Execute"},{"location":"action/execute/#importando","text":"from automation_studio.action import execute","title":"Importando"},{"location":"action/execute/#desactive_numlock","text":"Gerenciador de contexto que desativa o numlock enquanto executa o comando passado e reativa o numlock with desactive_numlock(): pyautogui.hotkey('ctrl','c') Alguns comandos do pyautogui n\u00e3o funciona com o numlock ativo. Return : None","title":"desactive_numlock"},{"location":"action/execute/#submit","text":"Aperta o Enter. submit() Return : None","title":"submit"},{"location":"action/execute/#copy","text":"Copia o elemento com \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy"},{"location":"action/execute/#copy_one_click","text":"Clica e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_one_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_one_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_one_click"},{"location":"action/execute/#copy_double_click","text":"Clica duas vezes e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_double_click) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_double_click()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_double_click"},{"location":"action/execute/#copy_press_home_end","text":"Clica no elemento aperta \"Home\" para ir para o come\u00e7o do elemento aperta \"Shift\" + \"End\" para selecionar todo elemento e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_home_end) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_home_end()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_press_home_end"},{"location":"action/execute/#copy_press_space","text":"Clica no elemento e aperta \"space\" para selecionar e copia o elemento \"CTRL\"+\"C\". Pode ser usado dentro do metodo copy do FireHiving no func_copy driver.find_element('element').copy(execute.copy_press_space) Obs: Voc\u00ea n\u00e3o pode passar a chamada da fun\u00e7\u00e3o \"copy_press_space()\", O metodo vai fazer a chamada da fun\u00e7\u00e3o dentro dele. PS: Elemento pode ser qualquer coisa que seja copiado. Um texto; uma pasta; um programa Return : Elemento copiado.","title":"copy_press_space"},{"location":"action/execute/#hot_key","text":"Executa comandos de teclado. \u00c9 a mistura do puautogui.press e o pyautogui.hotkey. Para n\u00e3o ficar importando a biblioteca pyautogui desnecessariamente. hot_key(args: Union[List, str, Tuple],time_after_press: float = 0, time_before_press: float = 0, **kwargs: Any) args :Union[List, str, Tuple]: Se for passado um str vai chamada o press do pyautogui, se passar uma lista ou tupla ele vai chamar o hotkey Exemplo: execute.hot_key('space') Ele s\u00f3 vai aperta o \"Space\" execute.hot_key(['ctrl', 'c']) Ele vai segura o \"CTRL\" e apertar \"C\" time/ after/_press _: float: Tempo que vai parar depois de apertar os bot\u00f5es. time/ before/_press _: float: Tempo que vai parar antes de apertar os bot\u00f5es. Exemplo: execute.hot_key('space', time_before_press=1, time_after_press=1) Nesse exemplo ele vai travar a execu\u00e7\u00e3o por 1 segundo, apertar \"Space\" e travar a execu\u00e7\u00e3o por 1 segundo. Return : None","title":"hot_key"},{"location":"action/execute/#maximize_screen","text":"Maximiza a tela. time/ before/_press _: float: Tempo que vai parar antes de maximiza a tela. Return : None","title":"maximize_screen"},{"location":"action/execute/#center_mouse","text":"Coloca o mouse no centro da tela. Return : None","title":"center_mouse"},{"location":"action/execute/#run_on_subprocess","text":"Executa comandos no prompt. driver : Driver: Driver com o arquivo toml. command : str: Comando dentro do toml que deseja executar. Exemplo: Vamos abrir o SAP. driver = Drive('config.toml') run_on_subprocess(driver, 'sap') Dentro do toml voc\u00ea precisa passar a do sap com o caminho do executavel. [command] sap = \"C:/Program Files (x86)/SAP/FrontEnd/SAPgui/saplogon.exe\" O run_on_subprocess vai dentro do toml buscar a chave command pegando o caminho do executavel do SAP. Return : None","title":"run_on_subprocess"},{"location":"action/execute/#window_close","text":"Fecha o programa. Vai fazer o \"ALT\" + \"F4\" simples. Return : None","title":"window_close"},{"location":"action/execute/#kill_process","text":"Mata o processo. Pode passar o nome do processo ou o PID. process : Union[str, int]: Nome ou PID do processo que deseja encerrar. Se passar o nome do processo n\u00e3o precisa passar a extens\u00e3o dele. Exemplo: Vamos fechar o chrome. kill_process('chrome') N\u00e3o precisa passar kill_process('chrome.exe') . Return : None","title":"kill_process"},{"location":"action/execute/#pid_process","text":"retorna o PID do processo. process :str: Nome do processo que deseja o PID. Return : int: O PID.","title":"pid_process"},{"location":"action/execute/#list_all_process","text":"Lista todos os processos no sistema. Return : List[dict[str, int]]: todos os processos do sistema.","title":"list_all_process"},{"location":"driver/driver/","text":"Usando o Driver O Driver como foi dito \u00e9 o orquestrador do Automation Studio. Ele \u00e9 bem simples basta voc\u00ea passar o caminho do arquivo do .toml. from automation_studio.prod_driver import Driver driver = Driver('arquivo.toml') S\u00f3 isso j\u00e1 \u00e9 necessario para conseguir fazer o driver orquestrar a biblioteca. O Driver retorna um objeto FindElement O Driver basicamente l\u00ea o arquivo toml. Argumentos O Driver tem a limita\u00e7\u00e3o de s\u00f3 interagir com elementos na tela primaria. Por isso no Driver tem argumento primary_screen que voc\u00ea seleciona a tela que deseja colocar como primaria. S\u00f3 que a\u00ed dependemos de outro programa para fazer isso. Voc\u00ea ter\u00e1 que baixar o nircmd que faz a troca da tela primaria. Voc\u00ea pode optar por fazer o download do nircmd e fazer essa troca pelo Driver ou voc\u00ea pode fazer a mudan\u00e7a no proprio Windows. Por default o driver vai buscar o nircmd no C:\\\\nircmd\\ , mas voc\u00ea pode mudar o caminho no Driver chame o argumento path_nircmd Vamos exemplificar. driver = Driver('config.toml', primary_screen=2, path_nircmd=r\"C:\\Users\\rodri\\Downloads\") O Prod Studio consegue mapear elementos mesmo que n\u00e3o estejam na tela primaria, mas voc\u00ea precisar\u00e1 passar no primary_screen a tela que deseja mapear e rodar o Driver antes de fazer o mapeamento. O Driver vai criar um arquivo metadata.json que dir\u00e1 ao Prod Studio qual tela voc\u00ea deseja mapear. Mas isso s\u00f3 serve para mapear elemento, para interagir voc\u00ea precisar\u00e1 fazer os passos acima.","title":"Driver"},{"location":"driver/driver/#usando-o-driver","text":"O Driver como foi dito \u00e9 o orquestrador do Automation Studio. Ele \u00e9 bem simples basta voc\u00ea passar o caminho do arquivo do .toml. from automation_studio.prod_driver import Driver driver = Driver('arquivo.toml') S\u00f3 isso j\u00e1 \u00e9 necessario para conseguir fazer o driver orquestrar a biblioteca. O Driver retorna um objeto FindElement O Driver basicamente l\u00ea o arquivo toml.","title":"Usando o Driver"},{"location":"driver/driver/#argumentos","text":"O Driver tem a limita\u00e7\u00e3o de s\u00f3 interagir com elementos na tela primaria. Por isso no Driver tem argumento primary_screen que voc\u00ea seleciona a tela que deseja colocar como primaria. S\u00f3 que a\u00ed dependemos de outro programa para fazer isso. Voc\u00ea ter\u00e1 que baixar o nircmd que faz a troca da tela primaria. Voc\u00ea pode optar por fazer o download do nircmd e fazer essa troca pelo Driver ou voc\u00ea pode fazer a mudan\u00e7a no proprio Windows. Por default o driver vai buscar o nircmd no C:\\\\nircmd\\ , mas voc\u00ea pode mudar o caminho no Driver chame o argumento path_nircmd Vamos exemplificar. driver = Driver('config.toml', primary_screen=2, path_nircmd=r\"C:\\Users\\rodri\\Downloads\") O Prod Studio consegue mapear elementos mesmo que n\u00e3o estejam na tela primaria, mas voc\u00ea precisar\u00e1 passar no primary_screen a tela que deseja mapear e rodar o Driver antes de fazer o mapeamento. O Driver vai criar um arquivo metadata.json que dir\u00e1 ao Prod Studio qual tela voc\u00ea deseja mapear. Mas isso s\u00f3 serve para mapear elemento, para interagir voc\u00ea precisar\u00e1 fazer os passos acima.","title":"Argumentos"},{"location":"driver/find/","text":"Encontrando Elemento Classe FindElement A classe FindElement tem as fun\u00e7\u00f5es para localizar o elemento na tela. find_element driver.find_element(\"elemento\") Procura o elemento na tela. find_element(*paths: str) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. Return : FireHiving: Objeto d\u00e1 interatividade ao elemento. first_to_find Procura o elemento na tela e retorna o primeiro elemento que encontrar. first_to_find(*paths: str, tip: List[int] = None) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. tip : int: Dica na tela de onde fica a imagem/video procurado Return : FireHiving: Objeto d\u00e1 interatividade ao elemento. implicitly_wait Vai travar a execu\u00e7\u00e3o do programa pelo tempo passado. \u00c9 bem parecido com o sleep. implicitly_wait(time: float) time :float: tempo que vai travar a execu\u00e7\u00e3o do programa.","title":"FindElement"},{"location":"driver/find/#encontrando-elemento","text":"","title":"Encontrando Elemento"},{"location":"driver/find/#classe-findelement","text":"A classe FindElement tem as fun\u00e7\u00f5es para localizar o elemento na tela.","title":"Classe FindElement"},{"location":"driver/find/#find_element","text":"driver.find_element(\"elemento\") Procura o elemento na tela. find_element(*paths: str) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. Return : FireHiving: Objeto d\u00e1 interatividade ao elemento.","title":"find_element"},{"location":"driver/find/#first_to_find","text":"Procura o elemento na tela e retorna o primeiro elemento que encontrar. first_to_find(*paths: str, tip: List[int] = None) paths : str: O nome dos caminhos das imagens/videos que ficam dentro do .toml. tip : int: Dica na tela de onde fica a imagem/video procurado Return : FireHiving: Objeto d\u00e1 interatividade ao elemento.","title":"first_to_find"},{"location":"driver/find/#implicitly_wait","text":"Vai travar a execu\u00e7\u00e3o do programa pelo tempo passado. \u00c9 bem parecido com o sleep. implicitly_wait(time: float) time :float: tempo que vai travar a execu\u00e7\u00e3o do programa.","title":"implicitly_wait"},{"location":"driver/fire/","text":"Interagindo com Elemento Depois de encontrar o elemento voc\u00ea normalmente vai querer interagir com ele. E \u00e9 nessa se\u00e7\u00e3o que voc\u00ea vai aprender as principais fun\u00e7\u00f5es. Click Clica no elemento. driver.find_element(\"elemento\").click() click(button: str = \"left\", clicks: int = 1, time_until_click: float = 0) button : str: Qual lado do mouse vai ser clicado. clicks : int: Quantas vezes o mouse vai clicar. time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None Hover Move o mouse para cima do elemento. driver.find_element(\"elemento\").hover() hover(time_until_hover: float = 0) time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None Writter Escreve o texto no elemento. driver.find_element(\"elemento\").writter() writter(text: str, clear: bool = False, time_until_writter: float = 0) text : str: Texto que ser\u00e1 escrito no elemento. clear : bool: Apaga o texto que j\u00e1 est\u00e1 no elemento antes de escrever. time until_writter _: float: Clica no elemento e aguarda o tempo passado antes de escrever. Return : None Copy Copia o elemento. driver.find_element(\"elemento\").copy() copy(func_copy: Any, safe_copy: bool = False, time_until_copy: float = 0) func_copy : Any: Fun\u00e7\u00e3o que ser\u00e1 chamada para fazer a copia. \"Detalhes abaixo\" safe_copy : bool: Certifica que a copia n\u00e3o est\u00e1 vazia. time_until_copy : float: Clica no elemento e aguarda o tempo passado antes de copiar. Return : None Algumas fun\u00e7\u00f5es para usar com o func copy _ est\u00e3o no modulo Execute , mas voc\u00ea tamb\u00e9m pode fazer a sua propria fun\u00e7\u00e3o. Drag_and_drop Clica e arrasta um elemento para cima do outro. driver.find_element(\"elemento_drag\", \"elemento_drop\").drag_and_drop() drag_and_drop(duration: float = 0.5) duration :float: Tempo que arrasta um elemento no outro Return : None Is_displayed driver.find_element(\"elemento\").is_displayed() Mostra se o elemento est\u00e1 na tela is_displayed() Return : bool x","title":"FireHiving"},{"location":"driver/fire/#interagindo-com-elemento","text":"Depois de encontrar o elemento voc\u00ea normalmente vai querer interagir com ele. E \u00e9 nessa se\u00e7\u00e3o que voc\u00ea vai aprender as principais fun\u00e7\u00f5es.","title":"Interagindo com Elemento"},{"location":"driver/fire/#click","text":"Clica no elemento. driver.find_element(\"elemento\").click() click(button: str = \"left\", clicks: int = 1, time_until_click: float = 0) button : str: Qual lado do mouse vai ser clicado. clicks : int: Quantas vezes o mouse vai clicar. time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None","title":"Click"},{"location":"driver/fire/#hover","text":"Move o mouse para cima do elemento. driver.find_element(\"elemento\").hover() hover(time_until_hover: float = 0) time until_click _: float: O mouse ser\u00e1 movido para cima do elemento e vai aguardar o tempo passado. Return : None","title":"Hover"},{"location":"driver/fire/#writter","text":"Escreve o texto no elemento. driver.find_element(\"elemento\").writter() writter(text: str, clear: bool = False, time_until_writter: float = 0) text : str: Texto que ser\u00e1 escrito no elemento. clear : bool: Apaga o texto que j\u00e1 est\u00e1 no elemento antes de escrever. time until_writter _: float: Clica no elemento e aguarda o tempo passado antes de escrever. Return : None","title":"Writter"},{"location":"driver/fire/#copy","text":"Copia o elemento. driver.find_element(\"elemento\").copy() copy(func_copy: Any, safe_copy: bool = False, time_until_copy: float = 0) func_copy : Any: Fun\u00e7\u00e3o que ser\u00e1 chamada para fazer a copia. \"Detalhes abaixo\" safe_copy : bool: Certifica que a copia n\u00e3o est\u00e1 vazia. time_until_copy : float: Clica no elemento e aguarda o tempo passado antes de copiar. Return : None Algumas fun\u00e7\u00f5es para usar com o func copy _ est\u00e3o no modulo Execute , mas voc\u00ea tamb\u00e9m pode fazer a sua propria fun\u00e7\u00e3o.","title":"Copy"},{"location":"driver/fire/#drag_and_drop","text":"Clica e arrasta um elemento para cima do outro. driver.find_element(\"elemento_drag\", \"elemento_drop\").drag_and_drop() drag_and_drop(duration: float = 0.5) duration :float: Tempo que arrasta um elemento no outro Return : None","title":"Drag_and_drop"},{"location":"driver/fire/#is_displayed","text":"driver.find_element(\"elemento\").is_displayed() Mostra se o elemento est\u00e1 na tela is_displayed() Return : bool x","title":"Is_displayed"},{"location":"prodstudio/prodstudio/","text":"Prod Studio N\u00e3o tem como usar o Automation Studio sem aprender o basico do Prod Studio . Com a nova vers\u00e3o do Prod Studio voc\u00ea n\u00e3o precisa mais criar a pasta para as imagens e o arquivo .toml. Na chamada do CLI do Prod Studio voc\u00ea passa o nome dos arquivos. Exemplo: python -m prod_studio config.toml img Se n\u00e3o arquivos \"config.toml\" e \"img\" n\u00e3o existirem, o prod_studio vai criar automaticamente. Como Usar O Automation Studio faz a instala\u00e7\u00e3o do prod studio por dependencia, mas caso deseja pode fazer a instala\u00e7\u00e3o pelo pip. pip install git+https://github.com/digital-path/prod_studio@default#egg=prod_studio Mapeando o elemento O mapeamento do elemento \u00e9 bem parecido com a DOM do html. Voc\u00ea vai selecionar uma \u00e0rea e o prod_studio vai te mostrar a precis\u00e3o que ele ter\u00e1 de encontrar aquele elemento na tela. Por default o prod_studio s\u00f3 retornar elementos com a precis\u00e3o acima de 0.9, para n\u00e3o ocorrer falso-positivo. \u00c9 sempre aconselhado tentar mapear elementos 1.0, mas qualquer coisa acima de 0.9 j\u00e1 \u00e9 bom. Elemento encontrado: Elemento n\u00e3o encontrado python -m prod_studio config.toml img Mapeamento Simples. Exemplo: Mapear o logo da Google. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F1 e levemente arraste para a parte inferior direita e verifica no terminal a precis\u00e3o de encontrar o elemento. Sempre entre 1.0 e 0.9. Quando atingir uma boa precis\u00e3o aperte F1 novamente para finalizar o mapeamento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. O terminal vai mostrar as chances do rob\u00f4 encontrar aquele elemento na tela. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Quando Usar: Sempre que houver um elemento simples de encontrar. Uma imagem, um bot\u00e3o algo que seja simples de distinguir de outros. Verifica se n\u00e3o h\u00e1 nenhuma outra imagem/bot\u00e3o identico ao que deseja mapear. O prod_studio leva em considera\u00e7\u00e3o o tamanho do elemento, a cor do elemento e etc... Mapeamento Multipla Exemplo: Mapear s\u00f3 um \"O\" do logo da Google. A sele\u00e7\u00e3o multipla \u00e9 bem parecida com a sele\u00e7\u00e3o simples. Coloque o mouse na parte superior esquerda do elemento pai aperte F2 e levemente arraste o mouse para a parte inferior direita e verifica no terminal a precis\u00e3o de encontrar o elemento. Sempre entre 1.0 e 0.9. Aperte F2 . Agora vai ao elemento filho que deseja mapear e fa\u00e7a o mesmo procedimento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. Dentro do .toml ser\u00e1 salvo um tip, esse tip \u00e9 a dica de onde o bot vai procurar o elemento. Primeiro faz o mapeamento do elemento pai. Depois faz o mapeamento do elemento filho dentro do pai. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Quando Usar: Quando h\u00e1 muitos elementos parecidos, quando voc\u00ea tem certeza que algo vai aparecer naquele exato local da tela. Preste bastante aten\u00e7\u00e3o pois ele vai buscar esse elemento exatamente no mesmo local da tela, ent\u00e3o se o elemento se mexer ou alguma coisa mudar ele n\u00e3o vai mais encontrar. Exemplo: H\u00e1 varias checkbox e voc\u00ea deseja marcar somente algumas. A sele\u00e7\u00e3o multipla \u00e9 muito bom para essa ocasi\u00e3o. Mapeamento OCR A sele\u00e7\u00e3o OCR encontra um texto na tela. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F3 e levemente arraste para a parte inferior direita e aperte F3 novamente para finalizar o mapeamento. O modo de sele\u00e7\u00e3o \u00e9 muito parecido com a sele\u00e7\u00e3o simples, mas n\u00e3o mostrar\u00e1 a precis\u00e3o do bot achar o elemento e sim o texto na tela encontrando. O texto ser\u00e1 salvo dentro do .toml com o tip. Voc\u00ea pode apagar o expected_text para encontrar qualquer texto dentro daquele tip. Mapeamento por video Bem parecido com a sele\u00e7\u00e3o simples. Ele grava a tela e salva como video. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F4 e levemente arraste para a parte inferior direita e aperte F4 novamente come\u00e7ar a gravar. Um contador vai mostrar o tempo de grava\u00e7\u00e3o. Aperte F4 para finalizar a grava\u00e7\u00e3o. O Video ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo do video ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. Resetar mapeamento Se n\u00e3o atingir a precis\u00e3o minima pode ser feita o reset da sele\u00e7\u00e3o aperte F9 para que volte ao estagio inicial. Poder\u00e1 selecionar novamente o elemento que deseja mapear. Cancelar mapeamento A qualquer momento aperte \"ESC\" para cancelar o mepeamento e destravar o terminal.","title":"Resumo"},{"location":"prodstudio/prodstudio/#prod-studio","text":"N\u00e3o tem como usar o Automation Studio sem aprender o basico do Prod Studio . Com a nova vers\u00e3o do Prod Studio voc\u00ea n\u00e3o precisa mais criar a pasta para as imagens e o arquivo .toml. Na chamada do CLI do Prod Studio voc\u00ea passa o nome dos arquivos. Exemplo: python -m prod_studio config.toml img Se n\u00e3o arquivos \"config.toml\" e \"img\" n\u00e3o existirem, o prod_studio vai criar automaticamente.","title":"Prod Studio"},{"location":"prodstudio/prodstudio/#como-usar","text":"O Automation Studio faz a instala\u00e7\u00e3o do prod studio por dependencia, mas caso deseja pode fazer a instala\u00e7\u00e3o pelo pip. pip install git+https://github.com/digital-path/prod_studio@default#egg=prod_studio","title":"Como Usar"},{"location":"prodstudio/prodstudio/#mapeando-o-elemento","text":"O mapeamento do elemento \u00e9 bem parecido com a DOM do html. Voc\u00ea vai selecionar uma \u00e0rea e o prod_studio vai te mostrar a precis\u00e3o que ele ter\u00e1 de encontrar aquele elemento na tela. Por default o prod_studio s\u00f3 retornar elementos com a precis\u00e3o acima de 0.9, para n\u00e3o ocorrer falso-positivo. \u00c9 sempre aconselhado tentar mapear elementos 1.0, mas qualquer coisa acima de 0.9 j\u00e1 \u00e9 bom. Elemento encontrado: Elemento n\u00e3o encontrado python -m prod_studio config.toml img","title":"Mapeando o elemento"},{"location":"prodstudio/prodstudio/#mapeamento-simples","text":"Exemplo: Mapear o logo da Google. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F1 e levemente arraste para a parte inferior direita e verifica no terminal a precis\u00e3o de encontrar o elemento. Sempre entre 1.0 e 0.9. Quando atingir uma boa precis\u00e3o aperte F1 novamente para finalizar o mapeamento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. O terminal vai mostrar as chances do rob\u00f4 encontrar aquele elemento na tela. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Quando Usar: Sempre que houver um elemento simples de encontrar. Uma imagem, um bot\u00e3o algo que seja simples de distinguir de outros. Verifica se n\u00e3o h\u00e1 nenhuma outra imagem/bot\u00e3o identico ao que deseja mapear. O prod_studio leva em considera\u00e7\u00e3o o tamanho do elemento, a cor do elemento e etc...","title":"Mapeamento Simples."},{"location":"prodstudio/prodstudio/#mapeamento-multipla","text":"Exemplo: Mapear s\u00f3 um \"O\" do logo da Google. A sele\u00e7\u00e3o multipla \u00e9 bem parecida com a sele\u00e7\u00e3o simples. Coloque o mouse na parte superior esquerda do elemento pai aperte F2 e levemente arraste o mouse para a parte inferior direita e verifica no terminal a precis\u00e3o de encontrar o elemento. Sempre entre 1.0 e 0.9. Aperte F2 . Agora vai ao elemento filho que deseja mapear e fa\u00e7a o mesmo procedimento. No terminal d\u00ea nome ao elemento e aperte ENTER . A imagem ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo da imagem ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio. Dentro do .toml ser\u00e1 salvo um tip, esse tip \u00e9 a dica de onde o bot vai procurar o elemento. Primeiro faz o mapeamento do elemento pai. Depois faz o mapeamento do elemento filho dentro do pai. Quanto mais perto de 1.0 melhor e o rob\u00f4 s\u00f3 encontrar\u00e1 elementos com precis\u00e3o acima de 0.9 Quando Usar: Quando h\u00e1 muitos elementos parecidos, quando voc\u00ea tem certeza que algo vai aparecer naquele exato local da tela. Preste bastante aten\u00e7\u00e3o pois ele vai buscar esse elemento exatamente no mesmo local da tela, ent\u00e3o se o elemento se mexer ou alguma coisa mudar ele n\u00e3o vai mais encontrar. Exemplo: H\u00e1 varias checkbox e voc\u00ea deseja marcar somente algumas. A sele\u00e7\u00e3o multipla \u00e9 muito bom para essa ocasi\u00e3o.","title":"Mapeamento Multipla"},{"location":"prodstudio/prodstudio/#mapeamento-ocr","text":"A sele\u00e7\u00e3o OCR encontra um texto na tela. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F3 e levemente arraste para a parte inferior direita e aperte F3 novamente para finalizar o mapeamento. O modo de sele\u00e7\u00e3o \u00e9 muito parecido com a sele\u00e7\u00e3o simples, mas n\u00e3o mostrar\u00e1 a precis\u00e3o do bot achar o elemento e sim o texto na tela encontrando. O texto ser\u00e1 salvo dentro do .toml com o tip. Voc\u00ea pode apagar o expected_text para encontrar qualquer texto dentro daquele tip.","title":"Mapeamento OCR"},{"location":"prodstudio/prodstudio/#mapeamento-por-video","text":"Bem parecido com a sele\u00e7\u00e3o simples. Ele grava a tela e salva como video. Coloque o mouse na parte superior esquerdo do elemento que deseja mapear aperte F4 e levemente arraste para a parte inferior direita e aperte F4 novamente come\u00e7ar a gravar. Um contador vai mostrar o tempo de grava\u00e7\u00e3o. Aperte F4 para finalizar a grava\u00e7\u00e3o. O Video ser\u00e1 salva dentro da pasta passada na chamada do CLI do Prod Studio. O caminho relativo do video ser\u00e1 escrito dentro do arquivo .toml passado na chamada do CLI do Prod Studio.","title":"Mapeamento por video"},{"location":"prodstudio/prodstudio/#resetar-mapeamento","text":"Se n\u00e3o atingir a precis\u00e3o minima pode ser feita o reset da sele\u00e7\u00e3o aperte F9 para que volte ao estagio inicial. Poder\u00e1 selecionar novamente o elemento que deseja mapear.","title":"Resetar mapeamento"},{"location":"prodstudio/prodstudio/#cancelar-mapeamento","text":"A qualquer momento aperte \"ESC\" para cancelar o mepeamento e destravar o terminal.","title":"Cancelar mapeamento"},{"location":"sobre/sobre/","text":"Sobre O Prod Studio e o Automation Studio nasceram para ajudar a equipe da DigitalPath automatizar rotinas do SAP. Mas foi ganhando novas fun\u00e7\u00f5es que n\u00e3o limitam essas ferramentas somente ao SAP. A ferramenta ainda continua limitada a equipe da digital path, mas qui\u00e7\u00e1 um dia n\u00e3o seja lan\u00e7ado no PYPI.","title":"Sobre"},{"location":"sobre/sobre/#sobre","text":"O Prod Studio e o Automation Studio nasceram para ajudar a equipe da DigitalPath automatizar rotinas do SAP. Mas foi ganhando novas fun\u00e7\u00f5es que n\u00e3o limitam essas ferramentas somente ao SAP. A ferramenta ainda continua limitada a equipe da digital path, mas qui\u00e7\u00e1 um dia n\u00e3o seja lan\u00e7ado no PYPI.","title":"Sobre"}]}